<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ramanjs.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ramanjs.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-08-25T06:21:14+00:00</updated><id>https://ramanjs.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Learncpp: 01 Functions and Files</title><link href="https://ramanjs.github.io/blog/2025/learncpp-01/" rel="alternate" type="text/html" title="Learncpp: 01 Functions and Files"/><published>2025-01-05T23:42:00+00:00</published><updated>2025-01-05T23:42:00+00:00</updated><id>https://ramanjs.github.io/blog/2025/learncpp-01</id><content type="html" xml:base="https://ramanjs.github.io/blog/2025/learncpp-01/"><![CDATA[<h2 id="function-return-values">Function Return Values</h2> <ol> <li>The <code class="language-plaintext highlighter-rouge">main()</code> function must return an <code class="language-plaintext highlighter-rouge">int</code>.</li> <li>Explicit function calls to <code class="language-plaintext highlighter-rouge">main()</code> should be avoided.</li> <li>Most compilers detect missing return values, but in complex cases, they might fail to do so.</li> <li><strong>Nested functions</strong> are not allowed in C++.</li> </ol> <h2 id="function-parameters-and-arguments">Function Parameters and Arguments</h2> <ol> <li>A <strong>parameter</strong> is a variable in a function’s header. It behaves like a regular variable but is initialized with a value provided by the caller.</li> <li>An <strong>argument</strong> is the actual value passed to a function when calling it.</li> <li>When a function is called: <ul> <li>Parameters are created as variables.</li> <li>Argument values are copied into parameters (<strong>pass by value</strong>).</li> <li>These parameters are called value parameters.</li> </ul> </li> <li><strong>Unreferenced parameters</strong> exist but are not used in the function body.</li> <li><strong>Unnamed parameters</strong> are parameters without a name.</li> </ol> <h2 id="local-scope">Local Scope</h2> <ol> <li><strong>Local variables</strong> are declared inside a function and only accessible within that function.</li> <li><strong>Creation &amp; Destruction</strong>: <ul> <li>Created when execution reaches their definition.</li> <li>Destroyed when they go out of scope (end of <code class="language-plaintext highlighter-rouge">{}</code> block).</li> </ul> </li> <li><strong>Scope &amp; Lifetime</strong>: <ul> <li>Scope defines where a variable is accessible.</li> <li>Lifetime lasts from creation to destruction.</li> <li>Temporary objects (e.g., function return values) exist briefly and are often optimized away in modern compilers.</li> </ul> </li> </ol> <h2 id="the-one-definition-rule-odr">The One Definition Rule (ODR)</h2> <p>C++ enforces <strong>one definition</strong> per entity across a program. ODR consists of three key rules:</p> <ol> <li><strong>Within a file</strong>: <ul> <li>Each function, variable, type, or template must have only one definition in a given scope.</li> <li>Definitions in separate scopes (e.g., different namespaces) are fine.</li> </ul> </li> <li><strong>Within a program</strong>: <ul> <li>Each function or variable must have <strong>only one definition across files</strong>.</li> <li>If multiple files define the same function/variable, it causes linker errors.</li> <li>Local variables and functions marked <code class="language-plaintext highlighter-rouge">static</code> or <code class="language-plaintext highlighter-rouge">inline</code> are exceptions.</li> </ul> </li> <li><strong>Multiple identical definitions are allowed</strong> for: <ul> <li><strong>Types</strong>, <strong>templates</strong>, <strong>inline functions</strong>, and <strong>inline variables</strong>.</li> <li>As long as each definition is identical across translation units.</li> </ul> </li> </ol> <h2 id="namespaces">Namespaces</h2> <ol> <li>A <strong>scope region</strong> ensures identifiers remain distinct from names declared elsewhere.</li> <li>A <strong>namespace</strong> introduces a new scope for identifiers, preventing conflicts.</li> <li>If an identifier isn’t inside a class, function, or namespace, it belongs to the <strong>global namespace</strong>.</li> <li>The <code class="language-plaintext highlighter-rouge">::</code> symbol is the <strong>scope resolution operator</strong>.</li> <li> <p>A <strong>using directive</strong> allows access to namespace members without a prefix:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// Avoid in large projects</span>
</code></pre></div> </div> </li> </ol> <h2 id="the-preprocessor">The Preprocessor</h2> <ol> <li>After preprocessing, a file becomes a <strong>translation unit</strong>.</li> <li><strong>Preprocessor directives</strong>: <ul> <li>Start with <code class="language-plaintext highlighter-rouge">#</code> and end with a newline (and not with a semicolon).</li> <li>Example: <code class="language-plaintext highlighter-rouge">#include</code>, <code class="language-plaintext highlighter-rouge">#define</code>, <code class="language-plaintext highlighter-rouge">#if</code>.</li> </ul> </li> <li><strong>Macros (<code class="language-plaintext highlighter-rouge">#define</code>)</strong>: <ul> <li> <p>Define <strong>object-like</strong> macros:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define IDENTIFIER
#define IDENTIFIER substitution_text
</span></code></pre></div> </div> </li> <li>Macros replace occurrences of <code class="language-plaintext highlighter-rouge">IDENTIFIER</code> with <code class="language-plaintext highlighter-rouge">substitution_text</code>.</li> <li>Function-like macros are discouraged.</li> </ul> </li> <li><strong>Conditional Compilation</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>  <span class="cp">#define PRINT_JOE
</span>
  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="cp">#ifdef PRINT_JOE
</span>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Joe</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// Compiled</span>
  <span class="cp">#endif
</span>
  <span class="cp">#ifdef PRINT_BOB
</span>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bob</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// Skipped</span>
  <span class="cp">#endif
</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">#if 0</code> for commenting out blocks</strong>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Joe</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="c">#if 0 // Disable this section
    std::cout &lt;&lt; "Bob\n";
    std::cout &lt;&lt; "Steve\n";
#endif
</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>Useful for disabling code blocks as nesting multiline (<code class="language-plaintext highlighter-rouge">/* */</code>) comments is not allowed.</li> </ul> </li> <li><strong>Scope of <code class="language-plaintext highlighter-rouge">#define</code></strong>: Preprocessor directives execute before compilation, <strong>top to bottom</strong>.</li> </ol> <h2 id="header-files">Header Files</h2> <ol> <li><strong>A source file should include its paired header</strong>: <ul> <li>Helps catch errors at compile time instead of link time.</li> <li>If a function’s return type differs in declaration and definition, the compiler throws an error.</li> <li>Overloaded functions (same name, different parameters) are not caught at this stage.</li> <li>Some necessary definitions may be in the header, making it <strong>mandatory</strong> to include.</li> </ul> </li> <li><strong>Angled Brackets (<code class="language-plaintext highlighter-rouge">&lt;&gt;</code>) vs. Double Quotes (<code class="language-plaintext highlighter-rouge">""</code>)</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">#include &lt;file&gt;</code></strong> : Searches <strong>system</strong> directories (used for standard headers).</li> <li><strong><code class="language-plaintext highlighter-rouge">#include "file"</code></strong> : Searches <strong>current</strong> directory first, then system directories.</li> </ul> </li> <li><strong>Why doesn’t <code class="language-plaintext highlighter-rouge">&lt;iostream&gt;</code> have <code class="language-plaintext highlighter-rouge">.h</code>?</strong> <ul> <li>Old C++ standard used <code class="language-plaintext highlighter-rouge">&lt;iostream.h&gt;</code>, which defined everything in the <strong>global namespace</strong>.</li> <li>The ANSI committee moved all standard library identifiers into the <strong><code class="language-plaintext highlighter-rouge">std</code> namespace</strong>.</li> <li>New-style headers omit <code class="language-plaintext highlighter-rouge">.h</code> to differentiate from old headers.</li> </ul> <table> <thead> <tr> <th>Header Type</th> <th>Naming Convention</th> <th>Example</th> <th>Namespace</th> </tr> </thead> <tbody> <tr> <td>C++ Specific (New)</td> <td><code class="language-plaintext highlighter-rouge">&lt;xxx&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;iostream&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">std</code></td> </tr> <tr> <td>C Compatibility (New)</td> <td><code class="language-plaintext highlighter-rouge">&lt;cxxx&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;cstddef&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">std</code> (required), global (optional)</td> </tr> <tr> <td>C++ Specific (Old)</td> <td><code class="language-plaintext highlighter-rouge">&lt;xxx.h&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;iostream.h&gt;</code></td> <td>Global</td> </tr> <tr> <td>C Compatibility (Old)</td> <td><code class="language-plaintext highlighter-rouge">&lt;xxx.h&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;stddef.h&gt;</code></td> <td>Global (required), <code class="language-plaintext highlighter-rouge">std</code> (optional)</td> </tr> </tbody> </table> </li> <li> <p><strong>Including headers from other directories</strong>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-o</span> main <span class="nt">-I</span>./source/includes main.cpp
</code></pre></div> </div> </li> </ol>]]></content><author><name></name></author><category term="summary"/><category term="learncpp"/><category term="c++"/><summary type="html"><![CDATA[Function Return Values]]></summary></entry><entry><title type="html">Learncpp: 02 Scope, Duration, and Linkage</title><link href="https://ramanjs.github.io/blog/2025/learncpp-02/" rel="alternate" type="text/html" title="Learncpp: 02 Scope, Duration, and Linkage"/><published>2025-01-05T23:42:00+00:00</published><updated>2025-01-05T23:42:00+00:00</updated><id>https://ramanjs.github.io/blog/2025/learncpp-02</id><content type="html" xml:base="https://ramanjs.github.io/blog/2025/learncpp-02/"><![CDATA[<h2 id="user-defined-namespaces">User-Defined Namespaces</h2> <ol> <li>C++ allows defining <strong>custom namespaces</strong> using the <code class="language-plaintext highlighter-rouge">namespace</code> keyword.</li> <li>A namespace must be declared at <strong>global scope</strong> or inside another namespace.</li> <li>To access an identifier inside a namespace, use the <strong>scope resolution operator (<code class="language-plaintext highlighter-rouge">::</code>)</strong>.</li> <li>The global scope resolution operator (<code class="language-plaintext highlighter-rouge">::</code>) before a function name allows calling the global version of a function explicitly.</li> <li>Namespace blocks can be declared in <strong>multiple</strong> locations, including: <ul> <li>Across multiple files in a project.</li> <li>In different parts of the same file.</li> </ul> </li> <li>Namespaces can be nested inside other namespaces.</li> <li>Long namespace names can be shortened using namespace <strong>aliases</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">Active</span> <span class="o">=</span> <span class="n">Foo</span><span class="o">::</span><span class="n">Goo</span><span class="p">;</span> <span class="c1">// Active now refers to Foo::Goo</span>
</code></pre></div> </div> </li> </ol> <h2 id="local-variables">Local Variables</h2> <ol> <li><strong>Scope</strong>: <ul> <li>Local variables have <strong>block scope</strong>.</li> <li>They are in scope from their definition to the end of the block they are declared in.</li> </ul> </li> <li><strong>Duration</strong>: <ul> <li>Local variables have <strong>automatic storage duration</strong>.</li> <li>They are created at the point of definition and destroyed at the end of the block.</li> </ul> </li> <li><strong>Linkage</strong>: <ul> <li><strong>Linkage</strong> determines if multiple declarations of an identifier refer to the same object.</li> <li>Local variables have <strong>no linkage</strong>, meaning each declaration of a local variable creates a <strong>new unique object</strong>.</li> </ul> </li> </ol> <h2 id="global-variables">Global Variables</h2> <ol> <li>A global variable is a variable declared outside of any function.</li> <li>It has global namespace scope, meaning it is visible from the point of declaration to the end of the file.</li> <li>Global variables have <strong>static duration</strong>, meaning: <ul> <li>They are <strong>created when the program starts</strong>.</li> <li>They are <strong>destroyed when the program ends</strong>.</li> </ul> </li> <li><strong>Initialization</strong>: <ul> <li>Unlike local variables, global variables are <strong>zero-initialized by default</strong>.</li> <li><strong>Constant global variables must be explicitly initialized</strong>.</li> </ul> </li> <li><strong>Shadowing</strong>: <ul> <li>A local variable with the same name as a global variable will <strong>shadow the global variable</strong>.</li> <li>The <strong>scope resolution operator (<code class="language-plaintext highlighter-rouge">::</code>)</strong> can be used to explicitly refer to the global variable.</li> </ul> </li> <li><strong>Best Practices</strong>: <ul> <li>Developers often prefix global variables with <code class="language-plaintext highlighter-rouge">"g_"</code> to indicate they are global.</li> <li>Use the <strong><code class="language-plaintext highlighter-rouge">-Wshadow</code> flag (GCC/Clang)</strong> to detect shadowed variables.</li> </ul> </li> </ol> <h2 id="internal-linkage">Internal Linkage</h2> <ol> <li>Internal linkage means the identifier is <strong>only accessible within the same translation unit</strong>.</li> <li>Global variables and functions can have <strong>internal or external linkage</strong>.</li> <li>Local variables <strong>always have no linkage</strong>.</li> <li><strong>Usage</strong>: <ul> <li>Use <code class="language-plaintext highlighter-rouge">static</code> to give a <strong>global variable internal linkage</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">static</span> <span class="kt">int</span> <span class="n">g_x</span><span class="p">{};</span> <span class="c1">// g_x is internal to this file</span>
</code></pre></div> </div> </li> <li><strong>Const and constexpr globals</strong> have <strong>internal linkage by default</strong>.</li> </ul> </li> <li><strong>Why Const Has Internal Linkage</strong>: <ul> <li>Const objects must be usable in constant expressions.</li> <li>This means the compiler must see a definition, not just a declaration.</li> <li>This allows header files to include constants <strong>without ODR violations</strong>.</li> </ul> </li> <li><strong>Functions with Internal Linkage</strong>: <ul> <li>Functions default to <strong>external linkage</strong>.</li> <li>They can be made <strong>internal</strong> using <code class="language-plaintext highlighter-rouge">static</code>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">static</span> <span class="kt">void</span> <span class="nf">helperFunction</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* Only accessible in this file */</span> <span class="p">}</span>
</code></pre></div> </div> </li> <li><strong>Unnamed namespaces</strong> provide internal linkage without using <code class="language-plaintext highlighter-rouge">static</code>.</li> </ul> </li> </ol> <h2 id="external-linkage-and-variable-forward-declarations">External Linkage and Variable Forward Declarations</h2> <ol> <li>External linkage allows identifiers to be accessed across translation units.</li> <li>Functions have <strong>external linkage</strong> by default.</li> <li><strong>Global Variables with External Linkage</strong>: <ul> <li>They are called <strong>external variables</strong>.</li> <li>To explicitly make a global variable external, use <code class="language-plaintext highlighter-rouge">extern</code>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">int</span> <span class="n">g_x</span> <span class="p">{</span> <span class="mi">2</span> <span class="p">};</span> <span class="c1">// non-constant globals are external by default (no need to use extern)</span>
 <span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">g_y</span> <span class="p">{</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// const globals can be defined as extern, making them external</span>
 <span class="k">extern</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">g_z</span> <span class="p">{</span> <span class="mi">3</span> <span class="p">};</span> <span class="c1">// constexpr globals can be defined as extern, making them external (but this is pretty useless)</span>
</code></pre></div> </div> </li> </ul> </li> <li><strong>Forward Declarations Using <code class="language-plaintext highlighter-rouge">extern</code></strong>: <ul> <li>Allows referencing variables <strong>defined in another file</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">extern</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">g_y</span><span class="p">;</span>
</code></pre></div> </div> </li> <li>Avoid using <code class="language-plaintext highlighter-rouge">extern</code> on a non-const variable with an initializer.</li> </ul> </li> </ol> <h2 id="why-non-const-global-variables-are-dangerous">Why Non-Const Global Variables Are Dangerous</h2> <ol> <li>Any function can modify global variables, making code <strong>hard to debug</strong>.</li> <li><strong>Initialization Order Problem</strong>: <ul> <li>Static initialization occurs in two phases: <ul> <li><strong>Constant initialization</strong>: Variables with <code class="language-plaintext highlighter-rouge">constexpr</code> initializers are initialized first.</li> <li><strong>Zero-initialization</strong>: Uninitialized variables are set to <code class="language-plaintext highlighter-rouge">0</code> before use.</li> </ul> </li> <li>Dynamic initialization happens later for <strong>non-constexpr initialized variables</strong>.</li> </ul> </li> <li><strong>Valid Use Cases</strong>: <ul> <li><strong>Logging systems</strong> often use global variables.</li> </ul> </li> </ol> <h2 id="inline-functions-and-variables">Inline Functions and Variables</h2> <ol> <li><strong>Function Call Overhead</strong>: <ul> <li>Function calls involve a <strong>performance cost</strong>.</li> <li><strong>Inline expansion</strong> replaces function calls with their actual code.</li> </ul> </li> <li><strong>Downside of Inline Expansion</strong>: <ul> <li>If a function is <strong>too large</strong>, replacing calls with code <strong>increases executable size</strong>.</li> </ul> </li> <li><strong>Modern <code class="language-plaintext highlighter-rouge">inline</code> Keyword</strong>: <ul> <li>It now means <strong>“multiple definitions are allowed”</strong> across translation units.</li> </ul> </li> <li><strong>Implicitly Inline Functions</strong>: <ul> <li>Functions defined <strong>inside classes</strong>.</li> <li><code class="language-plaintext highlighter-rouge">constexpr</code> or <code class="language-plaintext highlighter-rouge">consteval</code> functions.</li> </ul> </li> <li>Why not make all functions inline and defined in a header file? Mainly because doing so can increase your compile times significantly.</li> <li><strong>Inline Variables (C++17)</strong>: <ul> <li>Allow global variables <strong>to be defined in multiple files</strong>.</li> </ul> </li> </ol> <h2 id="sharing-global-constants-across-files">Sharing Global Constants Across Files</h2> <ol> <li><strong>Pre-C++17 Approach</strong>: <ul> <li>Create a <strong>header file</strong> with a <strong>namespace</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">namespace</span> <span class="n">constants</span> <span class="p">{</span>
  <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pi</span> <span class="p">{</span> <span class="mf">3.14159</span> <span class="p">};</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> <li>Changing a constant requires <strong>recompiling all files</strong>.</li> <li>Large constants can <strong>consume memory</strong>.</li> </ul> </li> <li><strong>C++17 Inline Variables</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">namespace</span> <span class="n">constants</span> <span class="p">{</span>
     <span class="kr">inline</span> <span class="k">constexpr</span> <span class="kt">double</span> <span class="n">pi</span> <span class="p">{</span> <span class="mf">3.14159</span> <span class="p">};</span>
 <span class="p">}</span>
</code></pre></div> </div> <ul> <li>Can be used in <strong>constant expressions across multiple files</strong>.</li> <li><strong>Only one copy</strong> of each variable exists.</li> </ul> </li> </ol> <h2 id="static-local-variables">Static Local Variables</h2> <ol> <li>Using the <code class="language-plaintext highlighter-rouge">static</code> keyword on a <strong>local variable</strong> changes its duration from <strong>automatic</strong> to <strong>static</strong>.</li> <li>A <strong>static local variable</strong>: <ul> <li>Persists for the entire program lifetime instead of being destroyed at block exit.</li> <li>Retains its value between function calls, unlike normal local variables.</li> </ul> </li> <li><strong>Initialization Rules</strong>: <ul> <li>If zero-initialized or initialized with a <code class="language-plaintext highlighter-rouge">constexpr</code> value, it is initialized at program start.</li> <li>If uninitialized or initialized with a non-constexpr value, it is zero-initialized at program start.</li> <li>If initialized with a non-constexpr expression, it is initialized only on the first function call.</li> </ul> </li> <li><strong>Re-initialization Behavior</strong>: <ul> <li>A static local variable is initialized only once.</li> <li>On subsequent function calls, the initialization does not happen again.</li> </ul> </li> <li><strong>Scope vs. Lifetime</strong>: <ul> <li>A static local variable has block scope, like a normal local variable.</li> <li>However, its lifetime extends until the program terminates, like a global variable.</li> </ul> </li> <li><strong>Const and <code class="language-plaintext highlighter-rouge">constexpr</code> Static Local Variables</strong>: <ul> <li>A <strong>const static local variable</strong> is useful when: <ul> <li>The value never changes.</li> <li>The initialization is <strong>expensive</strong> (e.g., reading from a file or database).</li> </ul> </li> <li>This ensures the function only computes the value once, instead of recalculating on every call.</li> </ul> </li> </ol>]]></content><author><name></name></author><category term="summary"/><category term="learncpp"/><category term="c++"/><summary type="html"><![CDATA[User-Defined Namespaces]]></summary></entry><entry><title type="html">Linux Device Drivers: 01 Introduction</title><link href="https://ramanjs.github.io/blog/2024/ldd3-01/" rel="alternate" type="text/html" title="Linux Device Drivers: 01 Introduction"/><published>2024-11-15T23:42:00+00:00</published><updated>2024-11-15T23:42:00+00:00</updated><id>https://ramanjs.github.io/blog/2024/ldd3-01</id><content type="html" xml:base="https://ramanjs.github.io/blog/2024/ldd3-01/"><![CDATA[<p>Welcome! This is the first installment in a series of blogs that I intend to write for the <a href="https://lwn.net/Kernel/LDD3/">LDD3</a> (Linux Device Drivers, 3rd Edition) book by Corbet et al. The book is quite old and focuses on version 2.6 of the Linux kernel. Although most of the content is still valid for the latest kernel tree, some APIs are no longer supported.</p> <p>Multiple open-source projects have ported the examples presented in the book to a newer kernel version (5.x). I wanted to write a series of blogs (10 - 15) that will concisely present the book’s subject matter along with the updated examples that can be tested on current systems. Through these blogs, I intend to teach myself device driver development while maintaining a summary that can be reviewed without rereading the book.</p> <h2 id="what-is-a-device-driver">What is a Device Driver</h2> <p>A driver acts as a black box that sits between the kernel and the device (hardware). It has to expose a standard interface, through which the kernel can interact with the device by making appropriate function calls. How those functions are implemented is managed by the driver, and is hidden from the kernel. A driver can be built separately from the kernel and loaded whenever required.</p> <p>Any piece of code that can be added to the kernel at runtime is called a <em>module</em>. A <em>module</em> can extend the kernel by providing new features not present when it was compiled. A device driver is also a type of module and deals with talking to hardware on behalf of the kernel.</p> <p>In Linux, devices can be categorised into broadly three types:</p> <ol> <li><strong>Character device</strong>: provide a stream of data, handled by a character (char) driver. Eg. keyboard, tty.</li> <li><strong>Block device</strong>: a disk which can host a filesystem.</li> <li><strong>Network device</strong>: NIC (Network Interface Card). Can send and receive data packets to other computers.</li> </ol> <p>Let’s build a simple Hello World module that does nothing significant except for printing a few statements inside the kernel logs.</p> <h2 id="setting-up-our-environment">Setting up our environment</h2> <p>Since we will be testing our modules by loading them into the kernel, it is advisable to setup a VM (Virtual Machine) to develop and test our code. Modules run in the kernel stack, and any bug in our module code can cause the host operating system to freeze (although rare). Go ahead and install Ubuntu on a VM.</p> <p>To build our modules, we require the kernel header files. They are available as a system package on most distributions and can be installed easily. However we will not take that route. instead we’ll download the linux source tree, that contains the header files, and compile our own kernel since that allows us to target our modules for a specific kernel version instead of the one running on the host. All examples in this series have been tested against v5.10.4.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.4.tar.xz
<span class="nb">tar</span> <span class="nt">-xf</span> linux-5.10.4.tar.xz
</code></pre></div></div> <p>Before compiling the kernel, we need to configure. Let’s go ahead with the default configuration as it suits our needs.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make defconfig
make menuconfig
</code></pre></div></div> <p>Compile the kernel:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span> bzImage
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span> modules
</code></pre></div></div> <p>Since we will be using the source tree to build our module, it is convenient to export a <code class="language-plaintext highlighter-rouge">KERNELDIR</code> environment. Append this to your <code class="language-plaintext highlighter-rouge">.bashrc</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">KERNELDIR</span><span class="o">=</span>/path/to/kernel/source
</code></pre></div></div> <h2 id="the-hello-world-module">The Hello World Module</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">whom</span> <span class="o">=</span> <span class="s">"Mom"</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">howmany</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">howmany</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">whom</span><span class="p">,</span>    <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">m_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_debug</span><span class="p">(</span><span class="s">"parameters test module is loaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">howmany</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_info</span><span class="p">(</span><span class="s">"#%d Hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">whom</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">m_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_debug</span><span class="p">(</span><span class="s">"parameters test module is unloaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">m_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">m_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"d0u9"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Module parameters test program"</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="linux"/><category term="summary"/><category term="device-drivers"/><summary type="html"><![CDATA[Introduction and setup for building and running modules in the kernel]]></summary></entry></feed>