<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ramanjs.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ramanjs.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-03-03T10:39:26+00:00</updated><id>https://ramanjs.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Learncpp: 01 Functions and Files</title><link href="https://ramanjs.github.io/blog/2025/learncpp-01/" rel="alternate" type="text/html" title="Learncpp: 01 Functions and Files"/><published>2025-01-05T23:42:00+00:00</published><updated>2025-01-05T23:42:00+00:00</updated><id>https://ramanjs.github.io/blog/2025/learncpp-01</id><content type="html" xml:base="https://ramanjs.github.io/blog/2025/learncpp-01/"><![CDATA[<h2 id="function-return-values">Function Return Values</h2> <ol> <li>The <code class="language-plaintext highlighter-rouge">main()</code> function must return an <code class="language-plaintext highlighter-rouge">int</code>.</li> <li>Explicit function calls to <code class="language-plaintext highlighter-rouge">main()</code> should be avoided.</li> <li>Most compilers detect missing return values, but in complex cases, they might fail to do so.</li> <li><strong>Nested functions</strong> are not allowed in C++.</li> </ol> <h2 id="function-parameters-and-arguments">Function Parameters and Arguments</h2> <ol> <li>A <strong>parameter</strong> is a variable in a function’s header. It behaves like a regular variable but is initialized with a value provided by the caller.</li> <li>An <strong>argument</strong> is the actual value passed to a function when calling it.</li> <li>When a function is called: <ul> <li>Parameters are created as variables.</li> <li>Argument values are copied into parameters (<strong>pass by value</strong>).</li> <li>These parameters are called value parameters.</li> </ul> </li> <li><strong>Unreferenced parameters</strong> exist but are not used in the function body.</li> <li><strong>Unnamed parameters</strong> are parameters without a name.</li> </ol> <h2 id="local-scope">Local Scope</h2> <ol> <li><strong>Local variables</strong> are declared inside a function and only accessible within that function.</li> <li><strong>Creation &amp; Destruction</strong>: <ul> <li>Created when execution reaches their definition.</li> <li>Destroyed when they go out of scope (end of <code class="language-plaintext highlighter-rouge">{}</code> block).</li> </ul> </li> <li><strong>Scope &amp; Lifetime</strong>: <ul> <li>Scope defines where a variable is accessible.</li> <li>Lifetime lasts from creation to destruction.</li> <li>Temporary objects (e.g., function return values) exist briefly and are often optimized away in modern compilers.</li> </ul> </li> </ol> <h2 id="the-one-definition-rule-odr">The One Definition Rule (ODR)</h2> <p>C++ enforces <strong>one definition</strong> per entity across a program. ODR consists of three key rules:</p> <ol> <li><strong>Within a file</strong>: <ul> <li>Each function, variable, type, or template must have only one definition in a given scope.</li> <li>Definitions in separate scopes (e.g., different namespaces) are fine.</li> </ul> </li> <li><strong>Within a program</strong>: <ul> <li>Each function or variable must have <strong>only one definition across files</strong>.</li> <li>If multiple files define the same function/variable, it causes linker errors.</li> <li>Local variables and functions marked <code class="language-plaintext highlighter-rouge">static</code> or <code class="language-plaintext highlighter-rouge">inline</code> are exceptions.</li> </ul> </li> <li><strong>Multiple identical definitions are allowed</strong> for: <ul> <li><strong>Types</strong>, <strong>templates</strong>, <strong>inline functions</strong>, and <strong>inline variables</strong>.</li> <li>As long as each definition is identical across translation units.</li> </ul> </li> </ol> <h2 id="namespaces">Namespaces</h2> <ol> <li>A <strong>scope region</strong> ensures identifiers remain distinct from names declared elsewhere.</li> <li>A <strong>namespace</strong> introduces a new scope for identifiers, preventing conflicts.</li> <li>If an identifier isn’t inside a class, function, or namespace, it belongs to the <strong>global namespace</strong>.</li> <li>The <code class="language-plaintext highlighter-rouge">::</code> symbol is the <strong>scope resolution operator</strong>.</li> <li> <p>A <strong>using directive</strong> allows access to namespace members without a prefix:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// Avoid in large projects</span>
</code></pre></div> </div> </li> </ol> <h2 id="the-preprocessor">The Preprocessor</h2> <ol> <li>After preprocessing, a file becomes a <strong>translation unit</strong>.</li> <li><strong>Preprocessor directives</strong>: <ul> <li>Start with <code class="language-plaintext highlighter-rouge">#</code> and end with a newline (and not with a semicolon).</li> <li>Example: <code class="language-plaintext highlighter-rouge">#include</code>, <code class="language-plaintext highlighter-rouge">#define</code>, <code class="language-plaintext highlighter-rouge">#if</code>.</li> </ul> </li> <li><strong>Macros (<code class="language-plaintext highlighter-rouge">#define</code>)</strong>: <ul> <li> <p>Define <strong>object-like</strong> macros:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define IDENTIFIER
#define IDENTIFIER substitution_text
</span></code></pre></div> </div> </li> <li>Macros replace occurrences of <code class="language-plaintext highlighter-rouge">IDENTIFIER</code> with <code class="language-plaintext highlighter-rouge">substitution_text</code>.</li> <li>Function-like macros are discouraged.</li> </ul> </li> <li><strong>Conditional Compilation</strong>: <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>  <span class="cp">#define PRINT_JOE
</span>
  <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
  <span class="p">{</span>
  <span class="cp">#ifdef PRINT_JOE
</span>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Joe</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// Compiled</span>
  <span class="cp">#endif
</span>
  <span class="cp">#ifdef PRINT_BOB
</span>      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Bob</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// Skipped</span>
  <span class="cp">#endif
</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
</code></pre></div> </div> </li> <li> <p><strong><code class="language-plaintext highlighter-rouge">#if 0</code> for commenting out blocks</strong>:</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Joe</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

<span class="c">#if 0 // Disable this section
    std::cout &lt;&lt; "Bob\n";
    std::cout &lt;&lt; "Steve\n";
#endif
</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div> </div> <ul> <li>Useful for disabling code blocks as nesting multiline (<code class="language-plaintext highlighter-rouge">/* */</code>) comments is not allowed.</li> </ul> </li> <li><strong>Scope of <code class="language-plaintext highlighter-rouge">#define</code></strong>: Preprocessor directives execute before compilation, <strong>top to bottom</strong>.</li> </ol> <h2 id="header-files">Header Files</h2> <ol> <li><strong>A source file should include its paired header</strong>: <ul> <li>Helps catch errors at compile time instead of link time.</li> <li>If a function’s return type differs in declaration and definition, the compiler throws an error.</li> <li>Overloaded functions (same name, different parameters) are not caught at this stage.</li> <li>Some necessary definitions may be in the header, making it <strong>mandatory</strong> to include.</li> </ul> </li> <li><strong>Angled Brackets (<code class="language-plaintext highlighter-rouge">&lt;&gt;</code>) vs. Double Quotes (<code class="language-plaintext highlighter-rouge">""</code>)</strong>: <ul> <li><strong><code class="language-plaintext highlighter-rouge">#include &lt;file&gt;</code></strong> : Searches <strong>system</strong> directories (used for standard headers).</li> <li><strong><code class="language-plaintext highlighter-rouge">#include "file"</code></strong> : Searches <strong>current</strong> directory first, then system directories.</li> </ul> </li> <li><strong>Why doesn’t <code class="language-plaintext highlighter-rouge">&lt;iostream&gt;</code> have <code class="language-plaintext highlighter-rouge">.h</code>?</strong> <ul> <li>Old C++ standard used <code class="language-plaintext highlighter-rouge">&lt;iostream.h&gt;</code>, which defined everything in the <strong>global namespace</strong>.</li> <li>The ANSI committee moved all standard library identifiers into the <strong><code class="language-plaintext highlighter-rouge">std</code> namespace</strong>.</li> <li>New-style headers omit <code class="language-plaintext highlighter-rouge">.h</code> to differentiate from old headers.</li> </ul> <table> <thead> <tr> <th>Header Type</th> <th>Naming Convention</th> <th>Example</th> <th>Namespace</th> </tr> </thead> <tbody> <tr> <td>C++ Specific (New)</td> <td><code class="language-plaintext highlighter-rouge">&lt;xxx&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;iostream&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">std</code></td> </tr> <tr> <td>C Compatibility (New)</td> <td><code class="language-plaintext highlighter-rouge">&lt;cxxx&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;cstddef&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">std</code> (required), global (optional)</td> </tr> <tr> <td>C++ Specific (Old)</td> <td><code class="language-plaintext highlighter-rouge">&lt;xxx.h&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;iostream.h&gt;</code></td> <td>Global</td> </tr> <tr> <td>C Compatibility (Old)</td> <td><code class="language-plaintext highlighter-rouge">&lt;xxx.h&gt;</code></td> <td><code class="language-plaintext highlighter-rouge">&lt;stddef.h&gt;</code></td> <td>Global (required), <code class="language-plaintext highlighter-rouge">std</code> (optional)</td> </tr> </tbody> </table> </li> <li> <p><strong>Including headers from other directories</strong>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>g++ <span class="nt">-o</span> main <span class="nt">-I</span>./source/includes main.cpp
</code></pre></div> </div> </li> </ol>]]></content><author><name></name></author><category term="summary"/><category term="learncpp"/><category term="c++"/><summary type="html"><![CDATA[Function Return Values]]></summary></entry><entry><title type="html">Linux Device Drivers: 01 Introduction</title><link href="https://ramanjs.github.io/blog/2024/ldd3-01/" rel="alternate" type="text/html" title="Linux Device Drivers: 01 Introduction"/><published>2024-11-15T23:42:00+00:00</published><updated>2024-11-15T23:42:00+00:00</updated><id>https://ramanjs.github.io/blog/2024/ldd3-01</id><content type="html" xml:base="https://ramanjs.github.io/blog/2024/ldd3-01/"><![CDATA[<p>Welcome! This is the first installment in a series of blogs that I intend to write for the <a href="https://lwn.net/Kernel/LDD3/">LDD3</a> (Linux Device Drivers, 3rd Edition) book by Corbet et al. The book is quite old and focuses on version 2.6 of the Linux kernel. Although most of the content is still valid for the latest kernel tree, some APIs are no longer supported.</p> <p>Multiple open-source projects have ported the examples presented in the book to a newer kernel version (5.x). I wanted to write a series of blogs (10 - 15) that will concisely present the book’s subject matter along with the updated examples that can be tested on current systems. Through these blogs, I intend to teach myself device driver development while maintaining a summary that can be reviewed without rereading the book.</p> <h2 id="what-is-a-device-driver">What is a Device Driver</h2> <p>A driver acts as a black box that sits between the kernel and the device (hardware). It has to expose a standard interface, through which the kernel can interact with the device by making appropriate function calls. How those functions are implemented is managed by the driver, and is hidden from the kernel. A driver can be built separately from the kernel and loaded whenever required.</p> <p>Any piece of code that can be added to the kernel at runtime is called a <em>module</em>. A <em>module</em> can extend the kernel by providing new features not present when it was compiled. A device driver is also a type of module and deals with talking to hardware on behalf of the kernel.</p> <p>In Linux, devices can be categorised into broadly three types:</p> <ol> <li><strong>Character device</strong>: provide a stream of data, handled by a character (char) driver. Eg. keyboard, tty.</li> <li><strong>Block device</strong>: a disk which can host a filesystem.</li> <li><strong>Network device</strong>: NIC (Network Interface Card). Can send and receive data packets to other computers.</li> </ol> <p>Let’s build a simple Hello World module that does nothing significant except for printing a few statements inside the kernel logs.</p> <h2 id="setting-up-our-environment">Setting up our environment</h2> <p>Since we will be testing our modules by loading them into the kernel, it is advisable to setup a VM (Virtual Machine) to develop and test our code. Modules run in the kernel stack, and any bug in our module code can cause the host operating system to freeze (although rare). Go ahead and install Ubuntu on a VM.</p> <p>To build our modules, we require the kernel header files. They are available as a system package on most distributions and can be installed easily. However we will not take that route. instead we’ll download the linux source tree, that contains the header files, and compile our own kernel since that allows us to target our modules for a specific kernel version instead of the one running on the host. All examples in this series have been tested against v5.10.4.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.4.tar.xz
<span class="nb">tar</span> <span class="nt">-xf</span> linux-5.10.4.tar.xz
</code></pre></div></div> <p>Before compiling the kernel, we need to configure. Let’s go ahead with the default configuration as it suits our needs.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make defconfig
make menuconfig
</code></pre></div></div> <p>Compile the kernel:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span> bzImage
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span> modules
</code></pre></div></div> <p>Since we will be using the source tree to build our module, it is convenient to export a <code class="language-plaintext highlighter-rouge">KERNELDIR</code> environment. Append this to your <code class="language-plaintext highlighter-rouge">.bashrc</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">KERNELDIR</span><span class="o">=</span>/path/to/kernel/source
</code></pre></div></div> <h2 id="the-hello-world-module">The Hello World Module</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">whom</span> <span class="o">=</span> <span class="s">"Mom"</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">howmany</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">howmany</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">whom</span><span class="p">,</span>    <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">m_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_debug</span><span class="p">(</span><span class="s">"parameters test module is loaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">howmany</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_info</span><span class="p">(</span><span class="s">"#%d Hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">whom</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">m_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_debug</span><span class="p">(</span><span class="s">"parameters test module is unloaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">m_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">m_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"d0u9"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Module parameters test program"</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="linux"/><category term="summary"/><category term="device-drivers"/><summary type="html"><![CDATA[Introduction and setup for building and running modules in the kernel]]></summary></entry></feed>