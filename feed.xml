<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="https://ramanjs.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ramanjs.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-02-24T19:21:14+00:00</updated><id>https://ramanjs.github.io/feed.xml</id><title type="html">blank</title><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">Linux Device Drivers: 01 Introduction</title><link href="https://ramanjs.github.io/blog/2024/ldd3-01/" rel="alternate" type="text/html" title="Linux Device Drivers: 01 Introduction"/><published>2024-11-15T23:42:00+00:00</published><updated>2024-11-15T23:42:00+00:00</updated><id>https://ramanjs.github.io/blog/2024/ldd3-01</id><content type="html" xml:base="https://ramanjs.github.io/blog/2024/ldd3-01/"><![CDATA[<p>Welcome! This is the first installment in a series of blogs that I intend to write for the <a href="https://lwn.net/Kernel/LDD3/">LDD3</a> (Linux Device Drivers, 3rd Edition) book by Corbet et al. The book is quite old and focuses on version 2.6 of the Linux kernel. Although most of the content is still valid for the latest kernel tree, some APIs are no longer supported.</p> <p>Multiple open-source projects have ported the examples presented in the book to a newer kernel version (5.x). I wanted to write a series of blogs (10 - 15) that will concisely present the book’s subject matter along with the updated examples that can be tested on current systems. Through these blogs, I intend to teach myself device driver development while maintaining a summary that can be reviewed without rereading the book.</p> <h2 id="what-is-a-device-driver">What is a Device Driver</h2> <p>A driver acts as a black box that sits between the kernel and the device (hardware). It has to expose a standard interface, through which the kernel can interact with the device by making appropriate function calls. How those functions are implemented is managed by the driver, and is hidden from the kernel. A driver can be built separately from the kernel and loaded whenever required.</p> <p>Any piece of code that can be added to the kernel at runtime is called a <em>module</em>. A <em>module</em> can extend the kernel by providing new features not present when it was compiled. A device driver is also a type of module and deals with talking to hardware on behalf of the kernel.</p> <p>In Linux, devices can be categorised into broadly three types:</p> <ol> <li><strong>Character device</strong>: provide a stream of data, handled by a character (char) driver. Eg. keyboard, tty.</li> <li><strong>Block device</strong>: a disk which can host a filesystem.</li> <li><strong>Network device</strong>: NIC (Network Interface Card). Can send and receive data packets to other computers.</li> </ol> <p>Let’s build a simple Hello World module that does nothing significant except for printing a few statements inside the kernel logs.</p> <h2 id="setting-up-our-environment">Setting up our environment</h2> <p>Since we will be testing our modules by loading them into the kernel, it is advisable to setup a VM (Virtual Machine) to develop and test our code. Modules run in the kernel stack, and any bug in our module code can cause the host operating system to freeze (although rare). Go ahead and install Ubuntu on a VM.</p> <p>To build our modules, we require the kernel header files. They are available as a system package on most distributions and can be installed easily. However we will not take that route. instead we’ll download the linux source tree, that contains the header files, and compile our own kernel since that allows us to target our modules for a specific kernel version instead of the one running on the host. All examples in this series have been tested against v5.10.4.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.10.4.tar.xz
<span class="nb">tar</span> <span class="nt">-xf</span> linux-5.10.4.tar.xz
</code></pre></div></div> <p>Before compiling the kernel, we need to configure. Let’s go ahead with the default configuration as it suits our needs.</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make defconfig
make menuconfig
</code></pre></div></div> <p>Compile the kernel:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span> bzImage
make <span class="nt">-j</span><span class="si">$(</span><span class="nb">nproc</span><span class="si">)</span> modules
</code></pre></div></div> <p>Since we will be using the source tree to build our module, it is convenient to export a <code class="language-plaintext highlighter-rouge">KERNELDIR</code> environment. Append this to your <code class="language-plaintext highlighter-rouge">.bashrc</code>:</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">export </span><span class="nv">KERNELDIR</span><span class="o">=</span>/path/to/kernel/source
</code></pre></div></div> <h2 id="the-hello-world-module">The Hello World Module</h2> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;linux/kernel.h&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">whom</span> <span class="o">=</span> <span class="s">"Mom"</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">howmany</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="n">module_param</span><span class="p">(</span><span class="n">howmany</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span>   <span class="n">S_IRUGO</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">whom</span><span class="p">,</span>    <span class="n">charp</span><span class="p">,</span> <span class="n">S_IRUGO</span><span class="p">);</span>

<span class="k">static</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">m_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_debug</span><span class="p">(</span><span class="s">"parameters test module is loaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">howmany</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pr_info</span><span class="p">(</span><span class="s">"#%d Hello, %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">whom</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span>
<span class="kt">void</span> <span class="n">__exit</span> <span class="nf">m_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pr_debug</span><span class="p">(</span><span class="s">"parameters test module is unloaded</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">m_init</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">m_exit</span><span class="p">);</span>

<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">"GPL"</span><span class="p">);</span>
<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">"d0u9"</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">"Module parameters test program"</span><span class="p">);</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="linux"/><category term="summary"/><category term="device-drivers"/><summary type="html"><![CDATA[Introduction and setup for building and running modules in the kernel]]></summary></entry></feed>